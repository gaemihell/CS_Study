# Transaction(트랜잭션)

- 트랜잭션은 DBMS에서 사용자 프로그램의 일회 실행이다.(동일한 프로그램을 여러번 실행하는 것은 여러 개의 트랜잭션을 생성하게 된다)
- 트랜잭션은 DBMS에서 변경의 기본 단이이며, 부분적으로 수행된 트랜잭션들은 허용되지 않는다.

## 트랜잭션의 ACID 성질

트랜잭션의 중요한 성질 4가지를 ACID라고 부른다.

- `원자성(Atomicity)` : 사용자가 각 트랜잭션의 수행을 `원자적(Atomicity)`으로 생각할 수 있도록 해야 한다. (각 트랜잭션의 연산이 모두 수행되거나 아예 다 수행되지 않아야 한다는 것이다.)
- `일관성(Consistency)` : 트랜잭션의 단독 수행은 `일관성(Consistency)`을 보장해야 한다. (시스템이 가지고 있는 고정요소는 수행 전후 상태가 같아야 한다.)
- `고립성(Isolation)` : 각 트랜잭션은 동시에 스케줄된 다른 트랜잭션들의 영향으로부터 고립되거나 보호되어야 한다.
- `영속성(Durability)` : DBMS가 트랜잭션이 성공적으로 완료하였다는 것을 사용자에게 통보하자마자 그 트랜잭션의 효과가 디스크에 반영되기 전에 시스템에 장애가 발생한다 하더라도 지속적으로 남아있어야 한다.(영구적으로 반영되어야 한다는 뜻)

이렇게 네가지의 앞 글자를 따써 ACID라고 부른다고 한다.

# 동시성 제어(Concurrency Protocol)

다중 사용자 환경을 지원하는 DBMS에서 여러 트랜잭션 간의 간섭으로 문제가 발생하지 않도록 트랜잭션의 실행 순서를 제어하는 기법이다.

이게 왜 필요한지 알아보자

## 동시성 제어의 필요성 - 끼어들기로 인한 문제

다중 사용자 환경에서는 한 트랜잭션이 수행될 때 다른 트랜잭션이 끼어들어 실행할 수 있는데, 이 때 트랜잭션들이 서로 간섭하면서 문제가 발생할 수 있다. 문제가 무엇인지, 예를 보면서 알아보자.

1. `갱신 분실(lost update)` : 이전 트랜잭션이 데이터를 변경한 후 트랜잭션을 종료하기 전에 다른 트랜잭션이 동일한 데이터를 갱신하여 덮어쓰는 경우, 이전 트랜잭션은 갱신한 값을 잃어버리게 된다.

그림을 살펴보면서 이해해 보자.

<p align="center">
  <img src="./img/lostupdate.jpeg">
  <br/> Lost Update
</p>

원래는 T1 -> T2로 수행한다면 전 직원의 봉급이 2000달러, 반대의 경우는 1000달러로 설정되어야 하지만, 이 결과는 어떠한 직렬 수행의 결과와도 일치하지 않는다. (일관성 위반)
T1 -> T2 순으로 트랜잭션이 종료 되었으므로 Larry의 봉급은 T2의 갱신을 반영해야하지만 T1의 반영이 갱신되었으므로, T2의 갱신이 분실 되었다.

2. `연쇄 복귀(cascading rollback)` or `회복 불가능(Unrecoverability)` : 특정 트랜잭션이 이전 상태로 rollback할 경우 아무 문제 없는 다른 트랜잭션까지 연달아 복귀하게 되는 문제를 말한다. 이때 한 트랜잭션이 이미 완료된 상태라면 지속성 조건에 따라 복귀가 불가능하다.

<p align="center">
  <img src="./img/nonrecoverable.png">
  <br/> Lost Update
</p>

-> 복구 가능 스케줄에서 트랜잭션들은 완료된 트랜잭션들만 읽는다. 그러면 그 스케줄은 복구 가능하며, 다른 트랜잭션들을 연쇄적으로 철회하지 않고 이루어지기 때문이다.

3. 불일치 분석(inconsistent analysis) : 여러 개의 트랜잭션이 끼어들기로 인해 트랜잭션의 일관성이 유지되지 못하는 상황을 말한다. 갱신 분실의 상황과 비슷하다.

4. 데이터 무결성 : 데이터 베이스내의 데이터가 얼마나 정확한지

## 끼어들기 문제들을 어떻게 해결해야 할까?

<p align="center">
  <img src="./img/types_of_schedules.jpg">
  <br/> Types of schedules
</p>

- 직렬 스케줄 혹은 직렬 가능한 스케줄로 만들어야 한다.
- 직렬 스케줄은 말 그대로 직렬로 실행되는 스케줄, 예를 들면 T1 -> T2 -> T3 이렇게 트랜잭션의 실행 순서롤 보장하는 스케줄이다.
- 그렇다면 직렬 가능한 스케줄은 무엇일까? -> 직렬 스케줄과 실행 결과가 동일한 스케줄을 말한다.
- 직렬 가능한 스케줄인지 판단하는 법 : 스케줄에 나타난 연산들의 순서를 전체적인 실행 결과에 영향을 끼치지 않으면서 교환하였을 때 직렬 스케줄로 변환되면 직렬 가능한 스케줄이다.
- 실행 순서룰 바꿀 수 있는 경우 : 서로 다른 데이터 항목에 대한 연산이거나, 같은 데이터 항목이라도 둘 다 `read 연산`인 경우에만 가능하다.

그러면 직렬 가능한 스케줄로 만드는 방법은 무엇이 있을까?

`Locking` 과 `TimeStamp` 두 가지 방법이 있는데, 대부분의 DBMS는 `Locking`을 사용한다고 한다.

트랜잭션의 실행 순서를 강제로 제어하여 직렬 가능한 스케줄로 보장하는 방법 중 하나인 `잠금(Locking)`에 대해서 알아보자.

## 잠금 프로토콜(locking protocol)

- 다른 사람들이 동일한 데이터를 동시에 접근하고 있다는 사실을 모를 정도로 자연스럽게 데이터의 동시접근을 계획하는 것은 DBMS에서 굉장히 중요한 임무 중 하나이다.(동시에 돈을 넣고 뺀다던가, 게시글을 읽고 수정하는 것 등등...)
- Locking Protocol은 이렇게 여러 트랜잭션들의 연산들이 `interleave` 하더라도, 실제 효과는 어떤 직렬 순서로 모든 트랜잭션들을 수행하는 것과 동일하다는 것을 보장하기 위해 각 트랜잭션이 준수해야 하는 규칙들의 모임이다.
- 하나의 트랜잭션이 데이터 항목에 대하여 잠금을 설정하면, 설정한 트랜잭션이 잠금을 해제할때 까지 독점적으로 사용할 수 있다.

<p align="center">
  <img src="./img/transaction_lock.png">
  <br/> Locking Protocol
</p>

- 잠금에는 두 가지 종류가 있는데,

  - 공용 잠금(Shared Lock) : 동시에 두 개의 다른 트랜잭션들에 의하여 소유될 수 있다.
  - 전용 잠금(Exclusive Lock) : 다른 트랜잭션들이 이 객체에 어떠한 잠금도 소유할 수 없도록 한다.

# Reference

[동시성 제어 기법 - 잠금 기법](https://medium.com/pocs/동시성-제어-기법-잠금-locking-기법-319bd0e6a68a)

[Geeks for Geeks](https://www.geeksforgeeks.org/types-of-schedules-in-dbms/)
